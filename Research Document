Research document

Subquestions:

Question 1:

What is the most secure way to track user identity via API?

Here we will discuss different ways to track user identity based on different authentication methods. First, we will discuss a few major approaches within the many proprietary authentication methods. We will also discuss the main advantages and disadvantages when using these authentication methods. At the end of this chapter you will find a brief recap of the different methods and a conclusion based on research.

Some major approaches in authentication:
    - HTTP Basic authentication
    - API Keys
    - OAuth

Token-based
Another method of verifying users is by creating a string of characters, or a "token", by the server which is then kept on the client for use in authorization later. The token has the advantage of being able to securely store and keep track of additional data, such as expiration date. The use of asymmetrical encryption can ensure that multiple parties are capable of verifying that the token is valid and the user is actually who they say they are, while only granting the capability of actually creating and correctly signing the token to a single entity. It has the additonal advantage of benig stateless; after the token has been created it does not rely on the state of any particular service to be used.



Question 2:

How can we establish a secure connection for exchanging information with the authentication mechanism?

In order to establish a secure connection between a client and a server both sides send a token to confirm the identity of the other.

The client’s security package sends an opaque message containing a token and any other application protocol relevant information to the client, the client sends the message to the server and the server sends it to it’s security package. The client and server can’t interpret or edit the message. The security package interprets the token and confirms whether or not the client was authenticated.

The client receives the server’s token in a message, it retrieves the token from the message and uses the token in a call to it’s security package. The client then calls the security package again to confirm whether or not a secure connection has been established.[1]

The main application protocols used for information transfer are:
    - HTTP
        HTTP stands for HyperText Transfer Protocol and is a protocol used to transfer unencrypted data
    - HTTPS
        HTTPS stands for HyperText Transfer Protocol Secure and is a protocol used for transfering encrypted data 
    - TELNET
        TELNET is an unencrypted protocol used for bidirectional text communicaiton using a terminal connection
    - FTP
        Stands for File Transfer Protocol it is used to transfer files between clients and servers. FTP is not encrypted.
    - SMTP
        Stands for Simple Mail Transfer Protocol is a communication protocol used for email transmission. SMTP is unencrypted.

Conclusion:
HTTPS is the best way to establish a secure connection with the authentication mechanism because the other protocols are unencrypted and/or used for different types of communication.


Question 3:

How can we securely store passwords and/or other authentication details on the server?

In this chapter we will discuss the different approaches to storing passwords and compare their respective advantages and disadvantages in the context of our authentication mechanism.
Furthermore, we will discuss which of these different approaches will be implemented in our authentication mechanism and why this choice was made.
This chapter will also discuss where and with what technology passwords and/or other authentication details can be securely saved.
During this research, different sources will be consulted to bring us closer to the answer to the question above.
These will be referenced at the end of the chapter.

Different approaches

Location and technology of storage

Database security

Data segmentation & seperation

Conclusion

Question 4:

What are the most secure algorithms for hashing authentication credentials?

Introduction
Many hashing functions have been designed over the years with varying strengths and vulnerabilities. We will judge some of the more popular algorithms on their speed, memory footprint, capabilities for GPU acceleration,
susceptibility to Application Specific Integrated Circuits (ASIC's) and Field-Programmable Gate Arrays (FPGA's).


PBKDF2

PBKDF2 is a key derivation functions with a sliding computational cost, used to reduce vulnerabilities to brute force attacks. [3]
Pros:
    - Faster then others, because it doesn't use block functions
    - More suitable for low memory systems

Cons:
    - Possible collision attacks
    - Uses little ram
    - Susceptible to brute forcing by gpu, fpga and asics

Argon2
Pros:
    - Resistant to acceleration by GPU, FPGA and ASIC for most Brute-Force and Dictionairy attacks (https://markeliasen.com/developers-its-2019-hash-password-accordingly/)
    - Argon2d (Suitable for Cryptocurrencies)
    - Argon2i (Suitable for Passwords, Protects againt side-channel leakage) (https://medium.com/@mpreziuso/password-hashing-pbkdf2-scrypt-bcrypt-and-argon2-e25aaf41598e)

Cons:
    - Lacking good library support
    - Can slow down when not properly configured
   

Scrypt
Scrypt was developed by Collin Percival while developing an online backup service. It requires a large amount of memory, though this requirement can be lowered at the cos to more processing power.
Pros:
    - Large memory use
    - Configurable strength
    -
    -

Cons:
    - Not designed to deter GPU based attacks
    - Not designed as a password hashing function, thus not particularly slow
    -
    
Sources:
    https://en.bitcoinwiki.org/wiki/Scrypt
    https://en.wikipedia.org/wiki/Scrypt

Bcrypt
Pros:
    - Key factor/Configurable slowness (cost)
    Extremely resistant to rainbow table-based attacks
    - Good output hash
    -
    -

Cons:
    - susceptible to gpu, fgpa and ascis
    - Increased load on server resources
    -
    -

Others

Conclusion

Based on our findings we will be using the Argon2 algorithm to hash passwords within our application. 
The main reason that led to this decision is Argon2's ability to protect against hardware attacks, such as fpga and asic based attacks, and it's resiliency to dictionary attacks.

Question 5:

What is the most secure way to segment the infrastructure of the authentication mechanism?

Question 6:

How can we test the security of the infrastructure of the authentication mechanism?

Sources:
[1]: https://docs.microsoft.com/en-us/windows/win32/secauthn/establishing-a-secure-connection-with-authentication
[2]: https://owasp.org/www-project-cheat-sheets/cheatsheets/Password_Storage_Cheat_Sheet
[3]: https://en.wikipedia.org/wiki/PBKDF2
